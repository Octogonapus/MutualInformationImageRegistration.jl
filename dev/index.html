<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · MutualInformationImageRegistration.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://Octogonapus.github.io/MutualInformationImageRegistration.jl/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>MutualInformationImageRegistration.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Octogonapus/MutualInformationImageRegistration.jl/blob/master/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="MutualInformationImageRegistration"><a class="docs-heading-anchor" href="#MutualInformationImageRegistration">MutualInformationImageRegistration</a><a id="MutualInformationImageRegistration-1"></a><a class="docs-heading-anchor-permalink" href="#MutualInformationImageRegistration" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/Octogonapus/MutualInformationImageRegistration.jl">MutualInformationImageRegistration</a>.</p><ul><li><a href="#MutualInformationImageRegistration.MutualInformationImageRegistration"><code>MutualInformationImageRegistration.MutualInformationImageRegistration</code></a></li><li><a href="#MutualInformationImageRegistration.mutual_information!-Tuple{MutualInformationContainer, Any, Any, Any, Any, Any, Any, AbstractMatrix{Float32}}"><code>MutualInformationImageRegistration.mutual_information!</code></a></li><li><a href="#MutualInformationImageRegistration.mutual_information!-Tuple{MutualInformationContainer, Any, Any}"><code>MutualInformationImageRegistration.mutual_information!</code></a></li><li><a href="#MutualInformationImageRegistration.mutual_information!-Tuple{MutualInformationContainer, Any, Any, Any, Any, Any, Any, Missing}"><code>MutualInformationImageRegistration.mutual_information!</code></a></li><li><a href="#MutualInformationImageRegistration.register!-Union{Tuple{T}, Tuple{MutualInformationContainer, AbstractMatrix{T}, AbstractMatrix{T}, AbstractVector{Int64}, AbstractVector{Int64}, AbstractVector{Int64}, AbstractMatrix{T}, Union{Missing, AbstractMatrix{Float32}}}} where T&lt;:Integer"><code>MutualInformationImageRegistration.register!</code></a></li><li><a href="#MutualInformationImageRegistration.register!-Union{Tuple{T}, Tuple{MutualInformationContainer, AbstractMatrix{T}, AbstractMatrix{T}, AbstractVector{Int64}, Int64, Int64, AbstractMatrix{T}}} where T&lt;:Integer"><code>MutualInformationImageRegistration.register!</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="MutualInformationImageRegistration.MutualInformationImageRegistration" href="#MutualInformationImageRegistration.MutualInformationImageRegistration"><code>MutualInformationImageRegistration.MutualInformationImageRegistration</code></a> — <span class="docstring-category">Module</span></header><section><div><p>MutualInformationImageRegistration performs image registration using mutual information.</p><pre><code class="language-julia">using MutualInformationImageRegistration, MutualInformationImageRegistration.FastHistograms, Random

# Create the container used to hold intermediate variables for registration
mi = MutualInformationContainer(
    create_fast_histogram(
        FastHistograms.FixedWidth(),
        FastHistograms.Arithmetic(),
        FastHistograms.NoParallelization(),
        [(0x00, 0xff, 4), (0x00, 0xff, 4)],
    ),
)

# Create the full image that the smaller images to register will be pulled from
full_image = rand(UInt8, 500, 300)
view(full_image, 300:330, 200:220) .= 0xff

# The fixed image is the image that the other images are registered against
fixed = full_image[(300-10):(330+10), (200-10):(220+10)]

# The max shift is the maximum search range
MAX_SHIFT = 11
# Padding is used to grow the bbox for higher quality registration
padding = [-10, -10, 10, 10]

# A buffer is needed to hold intermediate data
buffer = Array{UInt8}(undef, (size(fixed) .+ (MAX_SHIFT * 2))...)

# Introduce a random shift to the moving bbox
expected_x = rand(-5:5)
expected_y = rand(-5:5)

# Register the image given by the bbox (called the moving bbox) against the fixed image
shift, mm, mms = register!(
    mi,
    full_image,
    fixed,
    [300, 200, 330, 220] .+ padding .+ [expected_x, expected_y, expected_x, expected_y],
    MAX_SHIFT,
    MAX_SHIFT,
    buffer
)

# The shift we get out should be equal and opposite of the shift we applied
shift == (-expected_x, -expected_y)

# output

true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Octogonapus/MutualInformationImageRegistration.jl/blob/ab040f135d389eb78ca972a2673bfd336e96ac89/src/MutualInformationImageRegistration.jl#L12-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutualInformationImageRegistration.mutual_information!-Tuple{MutualInformationContainer, Any, Any, Any, Any, Any, Any, AbstractMatrix{Float32}}" href="#MutualInformationImageRegistration.mutual_information!-Tuple{MutualInformationContainer, Any, Any, Any, Any, Any, Any, AbstractMatrix{Float32}}"><code>MutualInformationImageRegistration.mutual_information!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mutual_information!(
    mi::MutualInformationContainer,
    fixed,
    buffer,
    ::Any,
    moving_bbox,
    range_x,
    range_y,
    prev_mis::AbstractArray{Float32,2};
    get_buffer_crop,
    kwargs...
)</code></pre><p>Calculates the mutual information of two images at all shifts within the <code>range_x</code> and <code>range_y</code>. Warm-starts the evaluation using previous results (<code>prev_mis</code>; the return value from a previous call of this function) and using the previously set and filtered contents of the <code>buffer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Octogonapus/MutualInformationImageRegistration.jl/blob/ab040f135d389eb78ca972a2673bfd336e96ac89/src/mutual_information.jl#L96-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutualInformationImageRegistration.mutual_information!-Tuple{MutualInformationContainer, Any, Any, Any, Any, Any, Any, Missing}" href="#MutualInformationImageRegistration.mutual_information!-Tuple{MutualInformationContainer, Any, Any, Any, Any, Any, Any, Missing}"><code>MutualInformationImageRegistration.mutual_information!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mutual_information!(
    mi::MutualInformationContainer,
    fixed,
    buffer,
    full_image,
    moving_bbox,
    range_x,
    range_y,
    ::Missing;
    set_buffer!,
    get_buffer_crop,
    prefilter_frame_crop! = x -&gt; nothing,
)</code></pre><p>Calculates the mutual information of two images at all shifts within the <code>range_x</code> and <code>range_y</code>. The <code>fixed</code> image must already be filtered. This will set the <code>buffer</code> and filter its contents using <code>prefilter_frame_crop!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Octogonapus/MutualInformationImageRegistration.jl/blob/ab040f135d389eb78ca972a2673bfd336e96ac89/src/mutual_information.jl#L42-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutualInformationImageRegistration.mutual_information!-Tuple{MutualInformationContainer, Any, Any}" href="#MutualInformationImageRegistration.mutual_information!-Tuple{MutualInformationContainer, Any, Any}"><code>MutualInformationImageRegistration.mutual_information!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mutual_information!(mi::MutualInformationContainer, x, y)</code></pre><p>Computes the mutual information between the two variables <code>x</code> and <code>y</code>. The histogram within <code>mi</code> must be of the correct type to handle the formats of <code>x</code> and <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Octogonapus/MutualInformationImageRegistration.jl/blob/ab040f135d389eb78ca972a2673bfd336e96ac89/src/mutual_information.jl#L30-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutualInformationImageRegistration.register!-Union{Tuple{T}, Tuple{MutualInformationContainer, AbstractMatrix{T}, AbstractMatrix{T}, AbstractVector{Int64}, AbstractVector{Int64}, AbstractVector{Int64}, AbstractMatrix{T}, Union{Missing, AbstractMatrix{Float32}}}} where T&lt;:Integer" href="#MutualInformationImageRegistration.register!-Union{Tuple{T}, Tuple{MutualInformationContainer, AbstractMatrix{T}, AbstractMatrix{T}, AbstractVector{Int64}, AbstractVector{Int64}, AbstractVector{Int64}, AbstractMatrix{T}, Union{Missing, AbstractMatrix{Float32}}}} where T&lt;:Integer"><code>MutualInformationImageRegistration.register!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">register!(
    mi::MutualInformationContainer,
    full_image::AbstractArray{T,2},
    fixed::AbstractArray{T,2},
    moving_bbox::AbstractVector{Int},
    range_x::AbstractVector{Int},
    range_y::AbstractVector{Int},
    buffer::AbstractArray{T,2},
    prev_mis::Union{Missing,AbstractArray{Float32,2}};
    set_buffer! = (buffer, current_frame, moving_bbox) -&gt; set_buffer!(buffer, current_frame, moving_bbox, maximum(range_x), maximum(range_y)),
    get_buffer_crop = (buffer, moving_bbox, shift_x, shift_y) -&gt; get_buffer_crop(buffer, moving_bbox, shift_x, shift_y, maximum(range_x), maximum(range_y)),
    prefilter_frame_crop! = x -&gt; nothing,
) where {T&lt;:Integer}</code></pre><p>Calculates the shift that best aligns the <code>moving_bbox</code> to the <code>fixed</code> image within the <code>full_image</code>. At a high level, this attempts to best match the view of <code>moving_bbox</code> inside <code>full_image</code> to the <code>fixed</code> image. This only considers shifts along the x and y axes; no rotation is considered. All combinations of shifts within <code>range_x</code> and <code>range_y</code> are considered.</p><p>Adding some padding to <code>moving_bbox</code> is a good idea to improve registration stability. E.g. <code>my_bbox .+ [-10, -10, 10, 10]</code>. You will need to determine the best padding value for your data.</p><p>The parameter <code>buffer</code> is required for temporary storage between calls to this function because it is assumed that you will call this function in a loop to register many similar images. Generally, you can define <code>buffer</code> as <code>Array{T}(undef, (size(fixed) .+ (MAX_SHIFT * 2))...)</code>. The buffer must have a size which is at least the size of the <code>fixed</code> image expanded by the maximum and minimum x and y shifts on each respective axis. The parameters <code>set_buffer!</code> and <code>get_buffer_crop</code> are used to write to and read from this buffer, respectively. There is typically no need to change these from their defaults.</p><p>The parameter <code>prev_mis</code> is used to memoize the mutual information calculations if this function is being called &quot;incrementally&quot; with an expanding shift horizon. If you are calling this function directly (and not in a loop to gradually expand a maximum shift horizon), you should set this to <code>missing</code>, which would cause all combinations of shifts within <code>range_x</code> and <code>range_y</code> to be considered.</p><p>The parameter <code>prefilter_frame_crop!</code> can be specified if you want to apply image filtering before computing the mutual information between the two images. This function must mutate the image it is given with whatever filtering operation you implement. Also, the <code>fixed</code> image must have the filtering pre-applied. See this package&#39;s tests for an example.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Octogonapus/MutualInformationImageRegistration.jl/blob/ab040f135d389eb78ca972a2673bfd336e96ac89/src/register.jl#L111-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutualInformationImageRegistration.register!-Union{Tuple{T}, Tuple{MutualInformationContainer, AbstractMatrix{T}, AbstractMatrix{T}, AbstractVector{Int64}, Int64, Int64, AbstractMatrix{T}}} where T&lt;:Integer" href="#MutualInformationImageRegistration.register!-Union{Tuple{T}, Tuple{MutualInformationContainer, AbstractMatrix{T}, AbstractMatrix{T}, AbstractVector{Int64}, Int64, Int64, AbstractMatrix{T}}} where T&lt;:Integer"><code>MutualInformationImageRegistration.register!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">register!(
    mi::MutualInformationContainer,
    full_image::AbstractArray{T,2},
    fixed::AbstractArray{T,2},
    moving_bbox::AbstractVector{Int},
    max_shift_x::Int,
    max_shift_y::Int,
    buffer::AbstractArray{T,2};
    set_buffer! = (buffer, current_frame, moving_bbox) -&gt; set_buffer!(buffer, current_frame, moving_bbox, max_shift_x, max_shift_y),
    get_buffer_crop = (buffer, moving_bbox, shift_x, shift_y) -&gt; get_buffer_crop(buffer, moving_bbox, shift_x, shift_y, max_shift_x, max_shift_y),
    prefilter_frame_crop! = x -&gt; nothing,
    start_shift_x = 3,
    start_shift_y = 3,
    expand_border = 1,
    expand_increment = 1,
) where {T&lt;:Integer}</code></pre><p>Calculates the shift that best aligns the <code>moving_bbox</code> to the <code>fixed</code> image within the <code>full_image</code>. At a high level, this attempts to best match the view of <code>moving_bbox</code> inside <code>full_image</code> to the <code>fixed</code> image. This only considers shifts along the x and y axes; no rotation is considered. This function incrementally expands the maximum shift horizon to evaluate as few shifts as possible. At a minimum, all shifts within <code>± start_shift_x</code> and <code>± start_shift_y</code> are considered. If the optimal shift falls within <code>expand_border</code> of the horizon, the horizon will be expanded by <code>expand_increment</code> and all new shifts will be evaluated. This process repeats until the optimal shift does not fall within <code>expand_border</code> of the horizon, or until the horizon has reached <code>max_shift_x</code> and <code>max_shift_y</code>.</p><p>Adding some padding to <code>moving_bbox</code> is a good idea to improve registration stability. E.g. <code>my_bbox .+ [-10, -10, 10, 10]</code>. You will need to determine the best padding value for your data.</p><p>The parameter <code>buffer</code> is required for temporary storage. Generally, you can define <code>buffer</code> as <code>Array{T}(undef, (size(fixed) .+ (MAX_SHIFT * 2))...)</code>. The buffer must have a size which is at least the size of the <code>fixed</code> image expanded by the maximum and minimum x and y shifts on each respective axis. The parameters <code>set_buffer!</code> and <code>get_buffer_crop</code> are used to write to and read from this buffer, respectively. There is typically no need to change these from their defaults.</p><p>The parameter <code>prefilter_frame_crop!</code> can be specified if you want to apply image filtering before computing the mutual information between the two images. This function must mutate the image it is given with whatever filtering operation you implement. Also, the <code>fixed</code> image must have the filtering pre-applied. See this package&#39;s tests for an example.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Octogonapus/MutualInformationImageRegistration.jl/blob/ab040f135d389eb78ca972a2673bfd336e96ac89/src/register.jl#L1-L40">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 15 June 2021 02:37">Tuesday 15 June 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
